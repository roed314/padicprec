\documentclass[sigconf]{acmart}

\setlength{\paperheight}{11in}
\setlength{\paperwidth}{8.5in}

\usepackage[utf8]{inputenc}

\hyphenation{regarding}

\usepackage{amsmath,amssymb}
%\usepackage{amsthmnoproof}
\usepackage{amsthm}
\usepackage{mathrsfs}
%\let\bibsection\relax
%\usepackage{amsrefs}
%\usepackage[usenames,dvipsnames]{color}
\usepackage{stmaryrd}
\usepackage{enumerate}
%\usepackage[algoruled,vlined,english,linesnumbered]{algorithm2e}
%\usepackage[pdfpagelabels,colorlinks=true,citecolor=blue]{hyperref}
\usepackage{comment}
\usepackage{multirow}
\usepackage{xspace}
\usepackage{tabularx,multicol}
%\usepackage{tikz}

\newcommand{\noopsort}[1]{}
\DeclareMathOperator{\NP}{NP}
\DeclareMathOperator{\HP}{HP}
\DeclareMathOperator{\PP}{PP}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\End}{End}
\DeclareMathOperator{\GL}{GL}
\DeclareMathOperator{\val}{val}
\DeclareMathOperator{\pr}{pr}
\DeclareMathOperator{\tr}{Tr}
\DeclareMathOperator{\adj}{Adj}
\DeclareMathOperator{\Grass}{Grass}
\DeclareMathOperator{\Lat}{Lat}
\DeclareMathOperator{\round}{round}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\rec}{rec}
\DeclareMathOperator{\cond}{cond}
\DeclareMathOperator{\disc}{Disc}
\DeclareMathOperator{\row}{row}
\DeclareMathOperator{\col}{col}

\newcommand{\N}{\mathbb N}
\newcommand{\Z}{\mathbb Z}
\newcommand{\Zp}{\Z_p}
\newcommand{\Q}{\mathbb Q}
\newcommand{\Qp}{\Q_p}
\newcommand{\Fp}{\mathbb{F}_p}
\newcommand{\Fq}{\mathbb{F}_q}
\newcommand{\R}{\mathbb R}
\newcommand{\OK}{\mathcal{O}_K}

\newcommand{\ZpL}{\texttt{ZpL}\xspace}
\newcommand{\ZpLCA}{\texttt{ZpLCA}\xspace}
\newcommand{\ZpLCR}{\texttt{ZpLCR}\xspace}
\newcommand{\ZpLF}{\texttt{ZpLF}\xspace}

\newcommand{\famN}{\mathcal{N}}

\newcommand{\llb}{[\mkern-2.5mu[}
\newcommand{\rrb}{]\mkern-2.5mu]}
\newcommand{\llp}{(\mkern-2.5mu(}
\newcommand{\rrp}{)\mkern-2.5mu)}

\newcommand{\calU}{\mathcal{U}}

\newcommand{\softO}{O\tilde{~}}

\newcommand{\inv}{\text{\rm inv}}
\newcommand{\app}{\text{\rm app}}

\def\todo#1{\ \!\!{\color{red} #1}}
\definecolor{purple}{rgb}{0.6,0,0.6}
\def\todofor#1#2{\ \!\!{\color{purple} {\bf #1}: #2}}

\newcommand{\done}[1]{\textcolor{blue}{#1}}
\newcommand{\tdo}[1]{\textcolor{red}{#1}}
\definecolor{answer}{rgb}{0,0.5,0.2}
\newcommand{\xavier}[1]{\textcolor{answer}{{\bf Xavier:} #1}}
\newcommand{\tristan}[1]{\textcolor{answer}{{\bf Tristan:} #1}}
\newcommand{\david}[1]{\textcolor{answer}{{\bf David:} #1}}

\def\binom#1#2{\Big(\begin{array}{cc} #1 \\ #2 \end{array}\Big)}

\clubpenalty=10000
\widowpenalty = 10000

\newtheorem{theo}{Theorem}[section]
\newtheorem{lem}[theo]{Lemma}
\newtheorem{prop}[theo]{Proposition}
\newtheorem{cor}[theo]{Corollary}
\newtheorem{quest}[theo]{Question}
\newtheorem{conj}[theo]{Conjecture}
\theoremstyle{definition}
\newtheorem{rem}[theo]{Remark}
\newtheorem{ex}[theo]{Example}
\newtheorem{deftn}[theo]{Definition}

\fancyhead{}

\begin{document}

\title{\ZpL: a p-adic precision package}

\author{Xavier Caruso}
  \affiliation{Universit\'e Rennes 1; \\
  %\institution{IRMAR}
  %\city{Rennes, France}
  %\postcode{35042}
}
\email{xavier.caruso@normalesup.org}
\author{David Roe}
  \affiliation{MIT; \\
  %\institution{Department of Mathematics}
  %\city{Pittsburgh, PA, USA}
  %\postcode{15260}
}
\email{roed@mit.edu}
\author{Tristan Vaccon}
  \affiliation{Universit\'e de Limoges; \\
  %\institution{CNRS, XLIM UMR 7252}
  %\city{Limoges, France}  
  %\postcode{87060}  
  }
\email{tristan.vaccon@unilim.fr}

\ccsdesc[500]{Computing methodologies~Algebraic algorithms}

\keywords{Algorithms, $p$-adic precision, characteristic polynomial,
eigenvalue}

\begin{abstract}
\end{abstract}

\maketitle

\section{Introduction}

When computing with real and $p$-adic fields, exact results are usually impossible, since most elements have infinite decimal or $p$-adic expansions.  Working with these fields thus requires an analysis of how precision evolves through the sequence of steps involved in carrying out a computation.  In this paper, we describe a package for computing with $p$-adic rings and fields, based on a series of papers by the same authors \todo{include citations}.  The core of the package is a method for tracking precision using $p$-adic lattices which can yield dramatically more precise results, at the cost of increased runtime and memory usage.

The standard method for handling precision when computing with real numbers is floating point arithmetic, which may also be used in $p$-adic computation.  At a given precision level, a finite set of representable numbers are chosen, and arithmetic operations are defined to give a representable number that is close to the true result \todo{add reference to floating point arithmetic}.  For example, the representable numbers in $53$-bit floating point arithmetic are those of the form $m \cdot 2^e$ \todo{describe valid $m$ and $e$}.  Floating point arithmetic has the benefit of efficient arithmetic operations, but users are responsible for tracking the precision of the results.  Numerically unstable algorithms can lead to very inaccurate answers \todo{add reference for numerical stability}.

If provably correct results are desired, interval arithmetic provides an alternative to floating point.  Instead of just tracking an approximation to the answer, the package also tracks a radius within which the true result lies.  This method is commonly used for $p$-adic computations since the ultrametric property of $p$-adic fields frequently keeps the radius small.  Computations remain fairly efficient with this approach, but numerical instability can still lead to dramatic losses in precision \todo{include reference to SOMOS section}.

For better control of precision, we may use ellipsoids rather than balls.  This change would have little utility for real numbers, since ellipsoids are not preserved by most functions.  For $p$-adic fields, in contrast, sufficiently small ellipsoids are preserved by differentiable maps.  From an algebraic perspective, these ellipsoids are just cosets of a lattice $H$ inside a $p$-adic vector space, and Lemma \todo{add number} describes how the image of such a coset under a map $f$ is given exactly by applying the differential of $f$ to $H$.

In this paper, we describe an implementation of this idea in Sage \todo{cite Sage}.  \todo{Add short description of package features.}

\todo{Plan of article}

\section{Examples}

\subsection{Elementary arithmetic}

\begin{tabular}{|l|l|}
\verb?R = Zp(3,5)? & \verb?R = ZpL(3,5)? \\
\verb?x = R(143,5); x? & \verb?x = R(143,5); x? \\
\hfill\verb?...12022? & \hfill\verb?...12022? \\
\verb?3*x? & \verb?3*x? \\
\hfill\verb?...120220? & \hfill\verb?...120220? \\
\verb?x + x + x? & \verb?x + x + x? \\
\hfill\verb?...20220? & \hfill\verb?...120220? \\
\verb?x^3? & \verb?x^3? \\
\hfill\verb?...020222? & \hfill\verb?...020222? \\
\verb?x * x * x? & \verb?x * x * x? \\
\hfill\verb?...20222? & \hfill\verb?...020222? \\
\end{tabular}

\begin{tabular}{|l|l|}
\verb?R = Zp(2,10)? & \verb?R = ZpL(2,10)? \\
\verb?x = R(987,10); x? & \verb?x = R(987,10); x? \\
\hfill\verb?...1111011011? & \hfill\verb?...1111011011? \\
\verb?y = R(21,5); y? & \verb?y = R(21,5); y? \\
\hfill\verb?...10101? & \hfill\verb?...10101? \\
\verb?u = x + y; u? & \verb?u = x + y; u? \\
\hfill\verb?...10000? & \hfill\verb?...10000? \\
\verb?v = x - y; v? & \verb?v = x - y; v? \\
\hfill\verb?...00110? & \hfill\verb?...00110? \\
\verb?u + v? & \verb?u + v? \\
\hfill\verb?...10110? & \hfill\verb?...11110110110? \\
\end{tabular}

\subsection{Linear algebra}

\begin{itemize}
\item determinant
\item characteristic polynomial
\end{itemize}

\subsection{Commutative algebra}

\begin{itemize}
\item gcd of polynomials
\end{itemize}

\section{Theory}

\subsection{The precision Lemma}

\subsection{The way the precision is tracked with \ZpL}

We follow the precision lattice.
Closely related to automatic differentiation.

\begin{itemize}
\item \ZpLCR, \ZpLCA: we use a cap to ensure that we have a lattice at
each step.
\item \ZpLF: we work with $\Zp$-submodules of possible positive codimension
and represent them using matrices of floating point $p$-adics.
\end{itemize}

\subsection{The notion of working precision}

\begin{itemize}
\item what is it?
\item how can we compute it? (Answer: Hermite reduction of the transpose)
\item how can we estimate it?
\end{itemize}

\subsection{Correctness}

\begin{itemize}
\item prove that \ZpLCA and \ZpLCR are correct under some assumptions
(to be determined)
\item explain that \ZpLF is not meant to provide proved results
\end{itemize}

\subsection{Complexity}

\begin{tabular}{l|c|c|}
& \ZpLCA/\ZpLCR & \ZpLF \\
\hline
Creation of a variable & $O(n)$ & $O(n_0)$ \\
\hline
Deletion of a variable & $O(m^2)$ & $-$ \\
\hline
\end{tabular}

discussion on temporal locality

\section{Presentation of the package}

\begin{itemize}
\item Discuss coercion/conversion: \texttt{Zp} coerces to \ZpL but no coersion
in the other direction
\item How to access to the precision
\item Diffused digits
\item Historic of variables creation/deletion, etc...
\item Other features?
\end{itemize}

\subsection{More examples}

\begin{tabular}{|l|l|}
\verb?R = Zp(2)? & \verb?R = ZpL(2)? \\
\multicolumn{2}{|l|}{\tt x, y, z, t = R(1,15), R(1,15), R(1,15), R(3,15)} \\
\multicolumn{2}{|l|}{\tt for \_ in range(20):} \\
\multicolumn{2}{|l|}{\tt \ \ \ \ x, y, z, t = y, z, t, (y*t + z*z)/x} \\
\multicolumn{2}{|l|}{\tt \ \ \ \ print t} \\
\hfill\verb?...000000000000100? & \hfill\verb?...000000000000100? \\
\hfill\verb?...000000000001101? & \hfill\verb?...000000000001101? \\
\hfill\verb?...000000000110111? & \hfill\verb?...000000000110111? \\
\hfill\verb?...101010111010111? & \hfill\verb?...101010111010111? \\
\hfill\verb?...1100111101111? & \hfill\verb?...101100111101111? \\
\hfill\verb?...1110000010010? & \hfill\verb?...111110000010010? \\
\hfill\verb?...0001000111001? & \hfill\verb?...100001000111001? \\
\hfill\verb?...0000011111101? & \hfill\verb?...100000011111101? \\
\hfill\verb?...1000000110101? & \hfill\verb?...001000000110101? \\
\hfill\verb?...101101010011? & \hfill\verb?...010101101010011? \\
\hfill\verb?...110000000000? & \hfill\verb?...001110000000000? \\
\hfill\verb?...000101011101? & \hfill\verb?...111000101011101? \\
\hfill\verb?...001001101011? & \hfill\verb?...111001001101011? \\
\hfill\verb?...000011110011? & \hfill\verb?...111000011110011? \\
\hfill\verb?...11? & \hfill\verb?...0000000111? \\
\hfill\verb?...10? & \hfill\verb?...1010001110? \\
\hfill\verb?...01? & \hfill\verb?...1110110001? \\
\hfill\verb?...01? & \hfill\verb?...011110111001? \\
\hfill\verb?...01? & \hfill\verb?...100101101001001? \\
\hfill\verb?...1? & \hfill\verb?...11111000011? \\
\end{tabular}

\begin{itemize}
\item SOMOS sequence
\item many multiplications of matrices
\item Dodgson algorithm
\item subresultants
\item Grobner basis
\item $p$-adic differential equations
\end{itemize}

\subsubsection{$p$-adic differential equations}


In \cite{LV16}, the behaviour of the precision when solving
$p$-adic differential equations with separation of 
variables has been studied.
The authors have investigated the gap when that appears
when applying a Newton-method solver between
the theoretic loss in precision and the 
actual loss in precision for a naive implemenationin \verb?Zp(p)?.
We can reach this theoretical loss in precision using \verb?ZpL?.
We use a generic \verb?Newton_Iteration_Solver(g,h,N)?
that applies \verb?N? steps of the Newton method for 
$y'=g \times h(y)$ as described in \cite{LV16}.

\begin{tabular}{|l|l|}
\verb?R = Qp(2,250)? & \verb?R = QpL(2,250)? \\
\verb?S = Zp(2,250)? & \verb?S = ZpL(2,250)? \\
\multicolumn{2}{|l|}{\tt A.<x> = PowerSeriesRing(R,32) } \\
\multicolumn{2}{|l|}{\tt B.<x> = PowerSeriesRing(S,32)) } \\
\multicolumn{2}{|l|}{\tt h,y =1+x+x\^{}3 , x+x\^{}2*A(B.random\_element()) } \\
\multicolumn{2}{|l|}{\tt g=y.derivative()/h(y) } \\
\multicolumn{2}{|l|}{\tt s=Newton\_Iteration\_Solver(g,h,5)} \\
\multicolumn{2}{|l|}{\tt print 250-(s[31].lift()-y[31].lift()).valuation(2)} \\
\hfill\verb?9? & \hfill\verb?4? \\
\end{tabular}
The theorical loss in precision for the coefficient of $t^{31}$
is $\lfloor log_2 (31)\rfloor=4$ and is then reached, whereas the
loss in precision for a naive implementation is clearly more severe.


\section{Conclusion}

\begin{itemize}
\item In which case should we use this package? Mainly for exploration
\item example of $p$-adic differential equations (especially for $p=2$)
\end{itemize}

\subsection{Exploration}

The purpose of this package is that of exploration
of the $p$-adic precision.
We conclude with a last example coming
from the field of the computation of
isogenies between elliptic curves over finite fields.
Techniques to compute these isogenies
through the solving of $p$-adic differential equations
have a long history, and a first
analysis of the behaviour of precision using
lattices has been investigated in \cite{LV16}.

In that article, the authors were interested in
solving $y'^2=g \times h(y)$ with
$g,h,y \in \mathbb{Z}_p \llbracket x \rrbracket$
such that $g(0)=h(0)=1$ and $y(0)=0.$

The main result was that the intrinsic loss in precision
when computing the coefficient $x^n$ of $y$
from $g$ and $h$ was in $\log_p(n)$
even though a naive analysis of
the Newton method for solving the equation
yield a loss in $\log_p(n)^2.$

However, this does not encompass the case of 
elliptic curves defined and isogeneous 
over $\mathbb{Q},$ which can yield a differential 
equation with a solution $y$ whose coefficients
have negative valuation.

For instance, the curves 
$E: \: y^2=x^3+1$
and $E': \: y^2= x^3+ (m^2-1)x^2/4 + m^6$ are isogeneous
over $\mathbb{Q}$ if  $m$ is an odd integer.
We take $m=67.$ The corresponding isogeny has coefficients with possibly
negative $3$-adic valuation.

We can solve numerically 
the corresponding differential equation
using the algorithm of \cite{Lercier-Sirvent:08}
over $\mathbb{Q}_3$ with lattice precision.
Any generic implementation of the Newton
method of \cite{Lercier-Sirvent:08} is enough.

\begin{tabular}{|l|}
\verb?    R = QpL(3)? \\
\verb?    A.<x> = PolynomialRing(R)?\\
\verb?    m=67?\\
\verb?    g=1+(1/4)*x^2+x^6?\\
\verb?    h=1+((m^2)/4)*x^2+m^6* x^6?\\
\verb?    y=Lercier_Sirvent(g,h,64)?\\
\verb?    y[31]?\\
\verb?(467995903278061284942799/3^14 + O(3^36))*x^31?\\
\end{tabular}

We can then see that up to $63,$ the behaviour
of the loss in relative precision is the same
as for the coefficient in $x^{31}$: \textbf{no loss
occured}.
Thus, those simple manipulations
hint at a different behaviour for the loss 
in precision in at least some special cases of
of isogenies defined over $\mathbb{Q}$
but not necessarily over $\mathbb{Z}_p.$ 

\bibliographystyle{plain}
\bibliography{ZpL}


\end{document}

